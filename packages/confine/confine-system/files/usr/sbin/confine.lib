#!/bin/bash

set -u


CONFINE_RPC_DIR=/var/run/confine/rpc

CONFINE_CONTAINER_NR_MIN_DEC=1
CONFINE_CONTAINER_NR_MAX_DEC=125 # there are only 126 private IPs.  126 is the RD itself

CONFINE_VNET_PREFIX="slv"

UCI_DEFAULT_PATH=/etc/config
ERR_LOG_TAG='CONFINE'


. /usr/sbin/lxc.functions
. /usr/sbin/confine.functions



confine_system_check() {

    uci_show confine-defaults soft,quiet >/dev/null || err $FUNCNAME "Missing config: confine-defaults"
    uci_show confine          soft,quiet >/dev/null || err $FUNCNAME "Missing config: confine"
    uci_show confine-slivers  soft,quiet >/dev/null || err $FUNCNAME "Missing config: confine-slivers"
    uci_show confine-slice-attributes  soft,quiet >/dev/null || err $FUNCNAME "Missing config: confine-slice-attributes"

    if uci changes -c $UCI_DEFAULT_PATH | \
	grep -e "^confine-" -e "^system\." -e "^network\." -e "^lxc\." > /dev/null ; then

	err $FUNCNAME "confine confing dirty! Please commit or revert"
    fi

    [ -d $CONFINE_RPC_DIR ] || mkdir -p $CONFINE_RPC_DIR

    local NODE_STATE="$( uci_get confine.node.state )"

    case "$NODE_STATE" in
	prepared|applied|started) ;;
	*) err $FUNCNAME "Confine node in disabled state=$NODE_STATE" ;;
    esac

}




confine_get_free_container_nr() {

#    echo "$FUNCNAME $# $@" >&2

    local SEARCH_BEGIN=$1 # max/min
    local OPT_CMD=${2:-}
    local CMD_SOFT=$( echo "$OPT_CMD" | grep -e "soft" > /dev/null && echo "soft," )

    local SLIVERS="$( uci_get_sections confine-slivers sliver soft )"
    local CONTAINERS="$( uci_get_sections lxc container soft )"

    local CONTAINER_NRS=
    local TMP_SL_ID=
    local TMP_CT_NR=

    for TMP_SL_ID in $SLIVERS ; do
	local HEX=$( uci_get confine-slivers.$TMP_SL_ID.sliver_nr soft,quiet)
	[ $HEX ] && CONTAINER_NRS="$( [ "$CONTAINER_NRS" ] && echo "$CONTAINER_NRS $HEX" || echo "$HEX" )"
    done

    for TMP_CT_NR in $CONTAINERS ; do
	local HEX=$( uci_get lxc.$TMP_CT_NR.container_nr soft,quiet)
	[ $HEX ] && CONTAINER_NRS="$( [ "$CONTAINER_NRS" ] && echo "$CONTAINER_NRS $HEX" || echo "$HEX" )"
    done

    #echo "SLIVERS=$SLIVERS CONTAINER_NRS=$CONTAINER_NRS" >&2


    local CT_NR_HEX=
    local CT_NR_DEC=$(( 16#${CT_NR_HEX} ))
    local DEC=

    for DEC in $( seq $CONFINE_CONTAINER_NR_MIN_DEC $CONFINE_CONTAINER_NR_MAX_DEC ) ; do

	local HEX=$( printf "%.2x\n" $( [ "$SEARCH_BEGIN" = "max" ] && \
	    echo $(( ( $CONFINE_CONTAINER_NR_MAX_DEC + 1 ) - $DEC )) ||  echo $DEC ) )

	if ! echo "$CONTAINER_NRS" | grep $HEX >/dev/null ; then

	    CT_NR_HEX=$HEX
	    break
	fi
    done
    

    [ $CT_NR_HEX ] || \
	{ err $FUNCNAME "Failed allocating sliver_nr" $CMD_SOFT; return 1; }
    
    echo $CT_NR_HEX
}




confine_allocate_public_ipv4() {

	echo "$FUNCNAME $@" >&2
	
	local DHCP_MAC=$1
	local OPT_CMD=${2:-}
	local CMD_SOFT=$( echo "$OPT_CMD" | grep -e "soft" > /dev/null && echo "soft," )
	
	local PROTOCOL="$( uci_get confine.node.sl_public_ipv4_proto soft)"
	local SLIVERS="$( uci_get_sections confine-slivers sliver soft )"
	local IF_KEYS="$( uci_get lxc.general.lxc_if_keys )"
	local IF_KEY=
	local PUBLIC4_COUNT=0
	local PUBLIC4_IPS=" "
	local TMP_SLIVER=
	for TMP_SLIVER in $SLIVERS ; do
		
		for IF_KEY in $IF_KEYS; do
			
			local IF_TYPE="$( uci_get confine-slivers.$TMP_SLIVER.if${IF_KEY}_type soft,quiet )"
			
			if [ "$IF_TYPE" = "public" ] || [ "$IF_TYPE" = "public4" ]; then
				PUBLIC4_COUNT="$(( $PUBLIC4_COUNT + 1 ))"
				
				local TMP_IP="$( uci_get confine-slivers.$TMP_SLIVER.if${IF_KEY}_ipv4 soft,quiet )"
				
				if [ "$TMP_IP" ] ; then
					
					echo "$PUBLIC4_IPS" | grep -e "$TMP_IP" >/dev/null && \
						{ err $FUNCNAME "public ip=$TMP_IP used twice !!!" $CMD_SOFT; return 1; }
					
					PUBLIC4_IPS="$( echo $PUBLIC4_IPS $TMP_IP )"
				fi
			fi
		done
		
		[ $PUBLIC4_COUNT -ge $( uci_get confine.node.public_ipv4_avail ) ] && \
			err $FUNCNAME "Failed allocating! Not enough public ipv4 adresses available!"			
	done
	

	
	if [ "$PROTOCOL" = "dhcp" ] ; then
		
		local DHCP_IF="test-dhcp"
	    
		ip link show $DHCP_IF > /dev/null 2>&1 || \
		    ip link add link br-local dev $DHCP_IF type macvlan
		
		ip link set $DHCP_IF down
		ip link set $DHCP_IF address $DHCP_MAC
		ip link set $DHCP_IF up
		
		local DHCP_RESULT="$( udhcpc -fqn -t 3 -i $DHCP_IF -s /usr/sbin/confine.udhcpc.test | grep result )"
		local DHCP_IP=$( echo $DHCP_RESULT | awk -F'addr=' '{print $2}' | awk '{print $1}' )
		
		ip link set $DHCP_IF down
		ip link del link br-local dev $DHCP_IF type macvlan
		
		[ "$DHCP_IP" ] || \
		    { err $FUNCNAME "Failed obtaining dhcp address" $CMD_SOFT; return 1; }
		
		echo "$PUBLIC4_IPS" | grep -e "$DHCP_IP" >/dev/null && \
		    { err $FUNCNAME "public ip=$TMP_IP already used !!!" $CMD_SOFT; return 1; }
		
		#err $FUNCNAME "DHCP_RESULT=$DHCP_RESULT DHCP_IP=$DHCP_IP" soft
		echo $DHCP_IP
		return 0
		
	elif [ "$PROTOCOL" = "static" ] ; then
	
		err $FUNCNAME "allocating free dhcp public ip from available IPs" soft
		local TMP_IP=
		for TMP_IP in "$( uci_get confine.node.sl_public_ipv4_addrs soft)" ; do
			
			if ! echo "$PUBLIC4_IPS" | grep -e "$TMP_IP" > /dev/null; then
				echo $TMP_IP
				return 0			
			fi
		done
	fi
	
	err $FUNCNAME "Failed allocating free public ip from available IPs" $CMD_SOFT
	return 1
}


confine_allocate_static_public_ipv4() {

    local OPT_CMD=${1:-}
    local CMD_SOFT=$( echo "$OPT_CMD" | grep -e "soft" > /dev/null && echo "soft," )

    local SLIVERS="$( uci_get_sections confine-slivers sliver soft )"
    local PROTO_IPS="$( uci_get confine.node.sl_public_ipv4_proto soft)"
    local TMP_SL_ID=
    local TMP_IP=
    local USED_IPS=

    [ "$PROTO_IPS" = "static" ] || \
	err $FUNCNAME "pre-allocation of public ipv4 addresses only possible with node.rd_public_ipv4_proto=static"

    for TMP_SL_ID in $SLIVERS; do

	if [ "$( uci_get confine-slivers.$TMP_SL_ID.if01_type soft,quiet )" = "public" ]; then
	    TMP_IP=$( uci_get confine-slivers.$TMP_SL_ID.if01_ipv4 soft,quiet )

	    if [ "$TMP_IP" ] ; then

		echo "$USED_IPS" | grep -e "$TMP_IP" >/dev/null && \
		    err $FUNCNAME "public ip=$TMP_IP used twice !!!"

		USED_IPS="$( [ "$USED_IPS" ] && echo "$USED_IPS $TMP_IP" || echo "$TMP_IP" )"
	    fi
	fi
    done


    for TMP_IP in "$( uci_get confine.node.sl_public_ipv4_addrs soft)" ; do

	if ! echo "$USED_IPS" | grep -e "$TMP_IP" > /dev/null; then

	    echo $TMP_IP
	    return 0

	fi
    done

    err $FUNCNAME "Failed allocating free public ip from available IPs" $CMD_SOFT

    return 1
}



confine_tinc_start() {
    echo "$FUNCNAME $@" >&2

    local TINC_CMD="tincd --logfile -n confine"
    $TINC_CMD
}

confine_tinc_stop() {

    echo "$FUNCNAME $@" >&2

    local TINC_CMD="tincd --logfile -n confine"
    local TINC_PID=$( ps | grep -e "$TINC_CMD" | grep -v grep | awk '{print $1}' )
    local TINC_CNT=0
    local TINC_MAX=20
    if [ "$TINC_PID" ] ; then 

	kill $TINC_PID

	echo -n "wait till tinc cleaned up "
	while [ $TINC_CNT -le $TINC_MAX ]; do
	    sleep 1
	    [ -x /proc/$TINC_PID ] || break
	    TINC_CNT=$(( TINC_CNT + 1 ))
	    echo -n "."
	done
	
	echo

	[ -x /proc/$TINC_PID ] && kill -9 $TINC_PID && \
	    echo "Killing confine tincd the hard way" >&2
    fi
}


confine_tinc_setup() {

    echo "$FUNCNAME $@" >&2

    local VCRD_ID=$1
    local VCRD_ID_DEC=$(( 16#${VCRD_ID} ))
    local SERVER_MGMT_IPV6_PREFIX48=$2

    confine_tinc_stop

    mkdir -p /etc/tinc/confine/hosts

    if ! [ -f /etc/tinc/confine/rsa_key.priv ]; then
	 echo "no /etc/tinc/confine/rsa_key.priv" >&2
        cp /etc/dropbear/openssh_rsa_host_key /etc/tinc/confine/rsa_key.priv
    fi

    ssh-keygen -e -m PEM -f /etc/tinc/confine/rsa_key.priv > /etc/tinc/confine/rsa_key.pub

    if ! [ -f /etc/tinc/confine/hosts/node_$VCRD_ID_DEC ]; then
	cat <<EOF > /etc/tinc/confine/hosts/node_$VCRD_ID_DEC
Subnet = $SERVER_MGMT_IPV6_PREFIX48:$VCRD_ID:0:0:0:0/64
$( cat /etc/tinc/confine/rsa_key.pub )
EOF
    fi

    local SERVER_CONFS=$(ls /etc/tinc/confine/hosts/ | grep -v node_$VCRD_ID_DEC)
    local SERVER_CONF=
    cat <<EOF > /etc/tinc/confine/tinc.conf
Name = node_$VCRD_ID_DEC
$( for SERVER_CONF in $SERVER_CONFS; do echo "ConnectTo = $SERVER_CONF"; done )
EOF


#    echo "$SERVER_TINC_KEY" > /etc/tinc/confine/server_rsa_key.pub
#    chmod 600 /etc/tinc/confine/server_rsa_key.pub
#
#    cat <<EOF > /etc/tinc/confine/hosts/server
#Address = $SERVER_TINC_IP
#Port = $SERVER_TINC_PORT
#Subnet = $SERVER_MGMT_IPV6_PREFIX48:0:0:0:0:2/128
#$( ssh-keygen -e -m PEM -f /etc/tinc/confine/server_rsa_key.pub )
#EOF
#
#    rm /etc/tinc/confine/server_rsa_key.pub

    cat <<EOF > /etc/tinc/confine/tinc-up
#!/bin/sh
ip -6 link set "\$INTERFACE" up mtu 1400
ip -6 addr add $SERVER_MGMT_IPV6_PREFIX48:$VCRD_ID:0:0:0:2/48 dev "\$INTERFACE"
EOF
    chmod u+rx /etc/tinc/confine/tinc-up

    cat <<EOF > /etc/tinc/confine/tinc-down
#!/bin/sh
ip -6 addr del $SERVER_MGMT_IPV6_PREFIX48:$VCRD_ID:0:0:0:2/48 dev "\$INTERFACE"
ip -6 link set "\$INTERFACE" down
EOF
    chmod u+rx /etc/tinc/confine/tinc-down

}


confine_node_disable() {

    echo "$FUNCNAME $@" >&2

    confine.lib confine_daemon_stop

    confine.lib uci_set confine.node.state=unprepared soft

    confine_tinc_stop

    confine_sliver_remove all
}

confine_node_enable() {

   echo "$FUNCNAME $@" >&2

    confine_system_check
    local NODE_STATE=$( uci_get confine.node.state soft )
    local VCRD_ID=$(    uci_get confine.node.id    soft )

    if ! check_node_state $NODE_STATE quiet,soft ; then
	
	confine_sliver_remove all
	return 1
    fi

    if [ "$NODE_STATE" = "started" ]; then

	confine.lib confine_system_check
    	echo "node-id=$VCRD_ID started"
	return 0
    fi


    if [ "$NODE_STATE" = "prepared" ] ; then

	confine_sliver_remove all

	local SERVER_MGMT_IPV6_PREFIX48=$( uci_get confine.testbed.mgmt_ipv6_prefix48           soft )

	local NODE_LOCAL_IFNAME=$(         uci_get confine.node.local_ifname                    soft )
	local NODE_PRIV_IPV4_PREFIX24=$(   uci_get confine.node.priv_ipv4_prefix24              soft )
	local NODE_PRIV_IPV6_PREFIX48=$(   uci_get confine-defaults.confine.priv_ipv6_prefix48  soft )
	local NODE_DBG_IPV6_PREFIX48=$(    uci_get confine-defaults.confine.debug_ipv6_prefix48 soft )
	local NODE_RD_PUBL_IPV4_PROTO=$(   uci_get confine.node.rd_public_ipv4_proto            soft )
	local NODE_RD_PUBL_IPV4=$(         uci_get confine.node.rd_public_ipv4                  soft,quiet )
	local NODE_RD_PUBL_IPV4_GW=$(      uci_get confine.node.rd_public_ipv4_gw               soft,quiet )
	local NODE_RD_PUBL_IPV4_DNS=$(     uci_get confine.node.rd_public_ipv4_dns              soft,quiet )
	local NODE_RD_ISOLATED_PARENTS=$(  uci_get confine.node.rd_if_iso_parents               soft,quiet )

	if true && \
	    [ "$VCRD_ID" ] && \
	    [ "$SERVER_MGMT_IPV6_PREFIX48" ] && \
	    [ "$NODE_LOCAL_IFNAME" ] && \
	    [ "$NODE_PRIV_IPV4_PREFIX24" ] && \
	    [ "$NODE_PRIV_IPV6_PREFIX48" ] && \
	    [ "$NODE_RD_PUBL_IPV4_PROTO" ] && \
	    true ; then

	    uci_set system.@system[0].hostname="rd${VCRD_ID}"

	    echo "rd${VCRD_ID}" > /proc/sys/kernel/hostname

	    if [ -f /etc/dropbear/openssh_rsa_host_key ]; then
		
		[ -f /etc/dropbear/dropbear_rsa_host_key ] && \
		    mv /etc/dropbear/dropbear_rsa_host_key /etc/dropbear/dropbear_rsa_host_key.old
		
		dropbearconvert openssh dropbear /etc/dropbear/openssh_rsa_host_key /etc/dropbear/dropbear_rsa_host_key

		diff /etc/dropbear/dropbear_rsa_host_key /etc/dropbear/dropbear_rsa_host_key.old >/dev/null 2>&1 || \
		    /etc/init.d/dropbear restart

	    elif [ -f /etc/dropbear/dropbear_rsa_host_key ]; then
		dropbearconvert dropbear openssh /etc/dropbear/dropbear_rsa_host_key /etc/dropbear/openssh_rsa_host_key 
	    fi

#	    if [ -f /etc/dropbear/dropbear_rsa_host_key ]; then

		dropbearkey -y -f /etc/dropbear/dropbear_rsa_host_key | grep ssh-rsa > /etc/dropbear/dropbear_rsa_host_key.pub
		ssh-keygen -e -m PEM -f /etc/dropbear/dropbear_rsa_host_key.pub > /etc/dropbear/openssh_rsa_host_key.pub
		
		confine_tinc_setup $VCRD_ID $SERVER_MGMT_IPV6_PREFIX48 # $SERVER_TINC_IP $SERVER_TINC_PORT "$SERVER_TINC_KEY"

#	    fi


	    echo "Configuring wireless... " >&2

	    if [ -f /etc/config/wireless ]; then
		mv  /etc/config/wireless  /etc/config/wireless.orig
	    fi
	    
	    wifi detect > /etc/config/wifi-detect
	    cp /etc/config/wifi-detect /etc/config/wireless 
	    
	    local WDEVS="$(uci_get_sections wifi-template wifi-device)"
	    local WDEV
	    for WDEV in $WDEVS; do

		echo "Configuring wifi-iface $WDEV ... " >&2

		if [ "$(uci_get wifi-template.${WDEV} soft,quiet)" = "wifi-device" ] && \
		    [ "$(uci_get wireless.${WDEV} soft,quiet)" = "wifi-device" ]; then

		    local WTEST=

#		    WTEST="$(uci_get wifi-template.${WDEV}.macaddr   soft,quiet)" && uci_set wireless.${WDEV}.macaddr="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.channel   soft,quiet)" && uci_set wireless.${WDEV}.channel="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.diversity soft,quiet)" && uci_set wireless.${WDEV}.diversity="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.txantenna soft,quiet)" && uci_set wireless.${WDEV}.txantenna="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.rxantenna soft,quiet)" && uci_set wireless.${WDEV}.rxantenna="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.country   soft,quiet)" && uci_set wireless.${WDEV}.country="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.outdoor   soft,quiet)" && uci_set wireless.${WDEV}.outdoor="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.hwmode    soft,quiet)" && uci_set wireless.${WDEV}.hwmode="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.htmode    soft,quiet)" && uci_set wireless.${WDEV}.htmode="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.txpower   soft,quiet)" && uci_set wireless.${WDEV}.txpower="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.noscan    soft,quiet)" && uci_set wireless.${WDEV}.noscan="$WTEST"
		    WTEST="$(uci_get wifi-template.${WDEV}.disabled  soft,quiet)" && \
			uci_set wireless.${WDEV}.disabled="$WTEST" || uci_del wireless.${WDEV}.disabled soft,quiet


		    local WTIF="$(uci_get_section_by_option wifi-template wifi-iface device $WDEV)"

		    local WDIF="$(uci_get_section_by_option wireless wifi-iface device $WDEV soft,quiet)"

		    if [ "$WDIF" ]; then
			
			WTEST="$(uci_get wifi-template.${WTIF}.network soft,quiet)" && \
			    uci_set wireless.${WTIF}.network="$WTEST" || uci_del wireless.${WTIF}.network soft,quiet

			WTEST="$(uci_get wifi-template.${WTIF}.mode soft,quiet)" && \
			    uci_set wireless.${WTIF}.mode="$WTEST" || uci_del wireless.${WTIF}.mode soft,quiet

			WTEST="$(uci_get wifi-template.${WTIF}.ssid soft,quiet)" && \
			    uci_set wireless.${WTIF}.ssid="$WTEST" || uci_del wireless.${WTIF}.ssid soft,quiet

			WTEST="$(uci_get wifi-template.${WTIF}.bssid soft,quiet)" && \
			    uci_set wireless.${WTIF}.bssid="$WTEST" || uci_del wireless.${WTIF}.bssid soft,quiet

			WTEST="$(uci_get wifi-template.${WTIF}.encryption soft,quiet)" && \
			    uci_set wireless.${WTIF}.encryption="$WTEST" || uci_del wireless.${WTIF}.encryption soft,quiet

			WTEST="$(uci_get wifi-template.${WTIF}.key soft,quiet)" && \
			    uci_set wireless.${WTIF}.key="$WTEST" || uci_del wireless.${WTIF}.key soft,quiet

			WTEST="$(uci_get wifi-template.${WTIF}.key1 soft,quiet)" && \
			    uci_set wireless.${WTIF}.key1="$WTEST" || uci_del wireless.${WTIF}.key1 soft,quiet

			WTEST="$(uci_get wifi-template.${WTIF}.key2 soft,quiet)" && \
			    uci_set wireless.${WTIF}.key2="$WTEST" || uci_del wireless.${WTIF}.key2 soft,quiet

			WTEST="$(uci_get wifi-template.${WTIF}.key3 soft,quiet)" && \
			    uci_set wireless.${WTIF}.key3="$WTEST" || uci_del wireless.${WTIF}.key3 soft,quiet

		    fi

		fi
	    done

	    wifi


	    echo "Configuring network... " >&2


#	    uci_del network.lan soft,quiet
#	    uci_del network.wan soft,quiet

	    uci_set network.internal=interface
	    uci_set network.internal.type=bridge
	    uci_set network.internal.ifname=dm-internal
	    uci_set network.internal.proto=static
	    uci_set network.internal.ipaddr=$NODE_PRIV_IPV4_PREFIX24.126
	    uci_set network.internal.netmask=$( ip4_net_to_mask /25 )
	    uci_set network.internal.ip6addr=$NODE_PRIV_IPV6_PREFIX48::1/64

	    uci_set network.local=interface
	    uci_set network.local.type=bridge
	    uci_set network.local.ifname="$NODE_LOCAL_IFNAME dm-local" # NODE_LOCAL_IFNAME MUST be first for MAC
#	    uci_set network.local.macaddr=$( ip link show dev eth0 | grep "link/ether" | awk '{print $2}' )
	    uci_set network.local.proto=$NODE_RD_PUBL_IPV4_PROTO




	    if [ "$NODE_RD_PUBL_IPV4_PROTO" = "static" ] && [ "$NODE_RD_PUBL_IPV4" ]; then

		uci_set network.local.proto=static
		uci_set network.local.ipaddr=$( echo $NODE_RD_PUBL_IPV4 | awk -F'/' '{print $1}' )
		uci_set network.local.netmask=$( ip4_net_to_mask $NODE_RD_PUBL_IPV4 )
		uci_set network.local.dns=$NODE_RD_PUBL_IPV4_DNS

		uci_set network.dflt_route=route
		uci_set network.dflt_route.interface=local
		uci_set network.dflt_route.target=0.0.0.0
		uci_set network.dflt_route.netmask=0.0.0.0
		uci_set network.dflt_route.gateway=$NODE_RD_PUBL_IPV4_GW

	    elif [ "$NODE_RD_PUBL_IPV4_PROTO" = "dhcp" ] ; then

		uci_set network.local.proto=dhcp
		uci_del network.local.ipaddr  soft,quiet
		uci_del network.local.netmask soft,quiet
		uci_del network.local.dns     soft,quiet
		uci_del network.dflt_route    soft,quiet

	    else 

		uci_set network.local.proto=none
		uci_del network.local.ipaddr  soft,quiet
		uci_del network.local.netmask soft,quiet
		uci_del network.local.dns     soft,quiet
		uci_del network.dflt_route    soft,quiet

	    fi

	    uci_set network.management=interface
	    uci_set network.management.ifname=br-local
	    uci_set network.management.proto=static
	    uci_set network.management.ip6addr=$SERVER_MGMT_IPV6_PREFIX48:$VCRD_ID::2/64

	    uci_set network.recovery1=interface
	    uci_set network.recovery1.ifname=br-local
	    uci_set network.recovery1.proto=static
	    uci_set network.recovery1.ipaddr=$NODE_PRIV_IPV4_PREFIX24.130
	    uci_set network.recovery1.netmask=$( ip4_net_to_mask /25 )
	    uci_set network.recovery1.ip6addr=$NODE_PRIV_IPV6_PREFIX48:0001::2/64

	    uci_set network.recovery2=interface
	    uci_set network.recovery2.ifname=br-local
	    uci_set network.recovery2.proto=static
	    uci_set network.recovery2.ip6addr=$NODE_PRIV_IPV6_PREFIX48:0002:$( eui64_from_link $NODE_LOCAL_IFNAME )/64

	    uci_set network.debug=interface
	    uci_set network.debug.ifname=br-local
	    uci_set network.debug.proto=static
	    uci_set network.debug.ip6addr=$NODE_DBG_IPV6_PREFIX48:$VCRD_ID::2/48

	    local ISO_DEV=
	    for ISO_DEV in $NODE_RD_ISOLATED_PARENTS; do
		uci_set network.$ISO_DEV=interface
		uci_set network.$ISO_DEV.ifname=$ISO_DEV
		uci_set network.$ISO_DEV.proto=static
		uci_set network.$ISO_DEV.ipaddr=0.0.0.0
	    done


	    /etc/init.d/network restart

	    confine.lib confine_system_check
	    
	    uci_set confine.node.state=applied

	else
	    uci_set confine.node.state=unprepared
	    err $FUNCNAME "Failed due to inproper confine.node config"
	fi

    fi

    local NODE_STATE=$( uci_get confine.node.state soft )

    if [ "$NODE_STATE" = "applied" ] ; then

	confine_system_check

	confine_sliver_stop all

	lsmod | grep dummy >/dev/null || insmod dummy
	ip link show dev dm-internal >/dev/null 2>&1 || ip link add dm-internal type dummy
	ip link show dev dm-local    >/dev/null 2>&1 || ip link add dm-local    type dummy

	local NODE_PRIV_IPV4_PREFIX24=$(   uci_get confine.node.priv_ipv4_prefix24 )

	iptables -L POSTROUTING -t nat -n | \
		grep -e "^MASQUERADE *all *-- *${NODE_PRIV_IPV4_PREFIX24}.0/25 *0.0.0.0/0$" >/dev/null || \
		iptables -I POSTROUTING -t nat -o br-local -s ${NODE_PRIV_IPV4_PREFIX24}.0/25 -j MASQUERADE

	iptables -L INPUT -t filter -n | \
		grep -e "^DROP *tcp *-- *0.0.0.0/0 *0.0.0.0/0 *tcp *dpts:49152:65535 *state *INVALID,NEW,RELATED,UNTRACKED" >/dev/null || \
		iptables -t filter -A INPUT -p tcp --dport 49152:65535 -i br-local -m state ! --state ESTABLISHED -j DROP

	iptables -L INPUT -t filter -n | \
		grep -e "^DROP *udp *-- *0.0.0.0/0 *0.0.0.0/0 *udp *dpts:49152:65535 *state *INVALID,NEW,RELATED,UNTRACKED" >/dev/null || \
		iptables -t filter -A INPUT -p udp --dport 49152:65535 -i br-local -m state ! --state ESTABLISHED -j DROP

	confine_tinc_stop
	confine_tinc_start
	
	uci_set confine.node.state=started

	confine.lib confine_daemon_continue

	return 0
    fi


    confine_sliver_remove all
    err $FUNCNAME "Illegal node state"
}

confine_sliver_allocate() {

    # echo "$FUNCNAME $# $@" >&2

    confine_system_check

    local SL_ID=$( check_slice_id $1 )
    local SRC="${2:--}"
    local SRC_CFG=$( date +%s )-$BASHPID-allocate-in
    local SRC_DIR=$CONFINE_RPC_DIR
    local SLV_CFG=$( date +%s )-$BASHPID-allocate-sliver
    local OUT_DIR=$CONFINE_RPC_DIR

    local LXC_IMAGES_PATH=$( uci_get lxc.general.lxc_images_path )
    
    cat $SRC > $SRC_DIR/$SRC_CFG

    local NODE_ID=$( uci_get confine.node.id )

    if [ "$( uci_get $SRC_CFG.$SL_ID soft,path=$SRC_DIR )" = "sliver" ] ; then


	uci_test confine-slivers.$SL_ID soft,quiet && \
	    err $FUNCNAME "slice=$SL_ID already defined"

	confine_sliver_remove $SL_ID quiet

	local USER_PUBKEY="$(   uci_get $SRC_CFG.$SL_ID.user_pubkey      soft,quiet,path=$SRC_DIR )"
	local EXP_NAME="$(      uci_get $SRC_CFG.$SL_ID.exp_name         soft,quiet,path=$SRC_DIR )"
	local FS_SIZE="$(       uci_get $SRC_CFG.$SL_ID.disk_mb          soft,quiet,path=$SRC_DIR )"
	local FS_URL="$(        uci_get $SRC_CFG.$SL_ID.fs_template_url  soft,quiet,path=$SRC_DIR )"
	local FS_TYPE="$(       uci_get $SRC_CFG.$SL_ID.fs_template_type soft,quiet,path=$SRC_DIR )"
	local DATA_URL="$(      uci_get $SRC_CFG.$SL_ID.exp_data_url     soft,quiet,path=$SRC_DIR )"
	local OVERLAY_URL="$(   uci_get $SRC_CFG.$SL_ID.overlay_url      soft,quiet,path=$SRC_DIR )"
	local MAC_PREFIX16="$(  uci_get confine.node.mac_prefix16 )"
	local PUBLIC4_PROTO="$( uci_get confine.node.sl_public_ipv4_proto soft)"

	local CT_NR
	CT_NR=$( confine_get_free_container_nr min soft )  || \
		err $FUNCNAME "Failed allocating sliver_nr"

	local IF_KEYS="$( uci_get lxc.general.lxc_if_keys )"
	local IF_KEY=

	local PUBLIC4_KEY=
	local PUBLIC4_IPV4=

	for IF_KEY in $IF_KEYS; do
	    local IF_TYPE="$( uci_get $SRC_CFG.$SL_ID.if${IF_KEY}_type soft,quiet,path=$SRC_DIR )"
	    
	    if [ "$IF_TYPE" ] && ( [ "$IF_TYPE" = "public" ] || [ "$IF_TYPE" = "public4" ] ); then
			PUBLIC4_KEY="$IF_KEY"
			break
	    fi
	done

	if [ "$PUBLIC4_KEY" ]; then
		
		local MAC=${MAC_PREFIX16}:${NODE_ID:0:2}:${NODE_ID:2:2}:${CT_NR}:${PUBLIC4_KEY}
		
		PUBLIC4_IPV4=$( confine_allocate_public_ipv4 $MAC soft ) || \
		    err $FUNCNAME "Failed allocating public ip"
	fi



	local VLAN_NR=$( uci_get $SRC_CFG.$SL_ID.vlan_nr soft,quiet,path=$SRC_DIR )
	if [ "$VLAN_NR" ] ; then

	    VLAN_NR=$( check_vlan_nr $VLAN_NR )
	    
	    local TMP_SLICES="$( uci_get_sections confine-slivers sliver soft )"
	    local TMP_SLICE=
	    for TMP_SLICE in $TMP_SLICES ; do

		if [ "$(uci_get confine-slivers.$TMP_SLICE.vlan_nr soft,quiet )" = "$VLAN_NR" ] ; then
		    err $FUNCNAME "$VLAN_NR already used by SLICE_ID=$TMP_SLICE"
		fi
	    done
	fi


	
	
	echo "" > $OUT_DIR/$SLV_CFG
	uci_set $SLV_CFG.$SL_ID=sliver path=$OUT_DIR

	[ "$USER_PUBKEY" ] && uci_set $SLV_CFG.$SL_ID.user_pubkey="$USER_PUBKEY"  path=$OUT_DIR
	[ "$EXP_NAME" ]    && uci_set $SLV_CFG.$SL_ID.exp_name="$EXP_NAME"        path=$OUT_DIR
	[ "$VLAN_NR" ]     && uci_set $SLV_CFG.$SL_ID.vlan_nr="$VLAN_NR"          path=$OUT_DIR
	[ "$FS_SIZE" ]     && uci_set $SLV_CFG.$SL_ID.disk_mb="$FS_SIZE"          path=$OUT_DIR
	[ "$FS_URL" ]      && uci_set $SLV_CFG.$SL_ID.fs_template_url="$FS_URL"   path=$OUT_DIR
	[ "$FS_TYPE" ]     && uci_set $SLV_CFG.$SL_ID.fs_template_type="$FS_TYPE" path=$OUT_DIR
	[ "$DATA_URL" ]    && uci_set $SLV_CFG.$SL_ID.exp_data_url="$DATA_URL"    path=$OUT_DIR
	[ "$OVERLAY_URL" ] && uci_set $SLV_CFG.$SL_ID.overlay_url="$OVERLAY_URL"  path=$OUT_DIR





	uci_set $SLV_CFG.$SL_ID.state=allocating path=$OUT_DIR
	uci_set $SLV_CFG.$SL_ID.sliver_nr=$CT_NR path=$OUT_DIR
	

	local IF_KEY=
	for IF_KEY in $IF_KEYS; do
	
	    local IF_TYPE="$( uci_get $SRC_CFG.$SL_ID.if${IF_KEY}_type soft,quiet,path=$SRC_DIR )"
	    if [ "$IF_TYPE" ]; then
		
		local IF_MAC=${MAC_PREFIX16}:${NODE_ID:0:2}:${NODE_ID:2:2}:${CT_NR}:${IF_KEY}
		local IF_NAME=$(   uci_get $SRC_CFG.$SL_ID.if${IF_KEY}_name   quiet,path=$SRC_DIR )
		local IF_PARENT=$( uci_get $SRC_CFG.$SL_ID.if${IF_KEY}_parent soft,quiet,path=$SRC_DIR )
		local IF_ISO_PARENTS="$( uci_get confine.node.rd_if_iso_parents soft,quiet )"
		
		
		if [ "$IF_TYPE" = "internal" ] || [ "$IF_TYPE" = "private" ]; then

		    local IF_PRIV_IPV4=$( uci_get confine.node.priv_ipv4_prefix24 ).$(( 16#${CT_NR} ))/25
		    local IF_PRIV_IPV6=$( uci_get confine-defaults.confine.priv_ipv6_prefix48 ):0:1000:${SL_ID:0:4}:${SL_ID:4:4}:${SL_ID:8:4}/64
		    
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_type=$IF_TYPE       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_name=$IF_NAME       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_mac=$IF_MAC         path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_ipv4=$IF_PRIV_IPV4  path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_ipv6=$IF_PRIV_IPV6  path=$OUT_DIR



		elif [ "$IF_TYPE" = "public" ]; then

		    local IF_MGMT_IPV6=$( uci_get confine.testbed.mgmt_ipv6_prefix48 ):${NODE_ID}:10${IF_KEY}:${SL_ID:0:4}:${SL_ID:4:4}:${SL_ID:8:4}/64
		    
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_type=$IF_TYPE       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_name=$IF_NAME       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_mac=$IF_MAC         path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_ipv6=$IF_MGMT_IPV6  path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_ipv4=$PUBLIC4_IPV4  path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_ipv4_proto=$PUBLIC4_PROTO path=$OUT_DIR
		    

		elif [ "$IF_TYPE" = "public4" ]; then

		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_type=$IF_TYPE       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_name=$IF_NAME       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_mac=$IF_MAC         path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_ipv4=$PUBLIC4_IPV4  path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_ipv4_proto=$PUBLIC4_PROTO path=$OUT_DIR

		elif [ "$IF_TYPE" = "management" ]; then

		    local IF_MGMT_IPV6=$( uci_get confine.testbed.mgmt_ipv6_prefix48 ):${NODE_ID}:10${IF_KEY}:${SL_ID:0:4}:${SL_ID:4:4}:${SL_ID:8:4}/64
		    
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_type=$IF_TYPE       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_name=$IF_NAME       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_mac=$IF_MAC         path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_ipv6=$IF_MGMT_IPV6  path=$OUT_DIR
		    
		    
		elif [ "$IF_TYPE" = "isolated" ] && [ "$IF_PARENT" ] && [ "$IF_ISO_PARENTS" ] && echo "$IF_ISO_PARENTS" | grep -e "$IF_PARENT" >/dev/null && ip link show $IF_PARENT >/dev/null 2>&1; then
		    
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_type=$IF_TYPE       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_name=$IF_NAME       path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_mac=$IF_MAC         path=$OUT_DIR
		    uci_set $SLV_CFG.$SL_ID.if${IF_KEY}_parent=$IF_PARENT   path=$OUT_DIR
		    
		else
		    err $FUNCNAME "Failed allocating sliver_id=$SL_ID if_type=$IF_TYPE" soft
		    continue
		fi

	    fi
	done




	if echo $FS_URL | grep -i debian >/dev/null || echo $FS_TYPE | grep -i debian >/dev/null ; then
		
	    lxc.lib lxc_create_uci $CT_NR confine-defaults.debian
	    uci_del lxc.$CT_NR.rootfs_url
	    
	    uci_set lxc.$CT_NR.customize=debian-confine.sh
	    
	elif echo $FS_URL | grep -i openwrt >/dev/null || echo $FS_TYPE | grep -i openwrt >/dev/null ; then

	    lxc.lib lxc_create_uci $CT_NR confine-defaults.openwrt
	    uci_del lxc.$CT_NR.rootfs_url
	    
	    uci_set lxc.$CT_NR.customize=openwrt-confine.sh
	    
	else
	    err $FUNCNAME "Unsupported Sliver fs or type"
	fi

	uci_set lxc.$CT_NR.remount="$LXC_IMAGES_PATH/$CT_NR/confine:confine" add
	uci_set lxc.$CT_NR.hostname=${SL_ID}_${NODE_ID}
	uci_set lxc.$CT_NR.tag=confine-sliver-$SL_ID

	local IF_KEY=
	for IF_KEY in $IF_KEYS; do
	
	    local IF_TYPE=$( uci_get $SLV_CFG.$SL_ID.if${IF_KEY}_type soft,quiet,path=$OUT_DIR )

	    if [ "$IF_TYPE" ]; then
		
		local IF_PAIR=${CONFINE_VNET_PREFIX}-${CT_NR}-${IF_KEY}

		local IF_NAME=$(    uci_get $SLV_CFG.$SL_ID.if${IF_KEY}_name       soft,path=$OUT_DIR )
		local IF_MAC=$(     uci_get $SLV_CFG.$SL_ID.if${IF_KEY}_mac        soft,quiet,path=$OUT_DIR )
		local IF_IPV4=$(    uci_get $SLV_CFG.$SL_ID.if${IF_KEY}_ipv4       soft,quiet,path=$OUT_DIR )
		local IF_IPV6=$(    uci_get $SLV_CFG.$SL_ID.if${IF_KEY}_ipv6       soft,quiet,path=$OUT_DIR )
		local IF_PARENT=$(  uci_get $SLV_CFG.$SL_ID.if${IF_KEY}_parent     soft,quiet,path=$OUT_DIR )
		local IF_VLANTAG=$( uci_get $SLV_CFG.$SL_ID.vlan_nr                soft,quiet,path=$OUT_DIR )
		
		if [ "$IF_TYPE" = "internal" ] || [ "$IF_TYPE" = "private" ]; then
		    
		    uci_set lxc.$CT_NR.if${IF_KEY}_type=veth
		    uci_set lxc.$CT_NR.if${IF_KEY}_pair=$IF_PAIR
		    uci_set lxc.$CT_NR.if${IF_KEY}_name=$IF_NAME
		    uci_set lxc.$CT_NR.if${IF_KEY}_netconf=internal
		    uci_set lxc.$CT_NR.if${IF_KEY}_mac=$IF_MAC
#		    uci_set lxc.$CT_NR.if${IF_KEY}_ipv4_proto=static
#		    uci_set lxc.$CT_NR.if${IF_KEY}_ipv4=$IF_IPV4
#		    uci_set lxc.$CT_NR.if${IF_KEY}_ipv6_proto=static
#		    uci_set lxc.$CT_NR.if${IF_KEY}_ipv6=$IF_IPV6


		elif [ "$IF_TYPE" = "public" ] || [ "$IF_TYPE" = "public4" ]; then

		    uci_set lxc.$CT_NR.if${IF_KEY}_type=veth
		    uci_set lxc.$CT_NR.if${IF_KEY}_pair=$IF_PAIR
		    uci_set lxc.$CT_NR.if${IF_KEY}_name=$IF_NAME
		    uci_set lxc.$CT_NR.if${IF_KEY}_netconf=local
		    uci_set lxc.$CT_NR.if${IF_KEY}_mac=$IF_MAC
#		    uci_set lxc.$CT_NR.if${IF_KEY}_ipv4_proto=$PUBLIC4_PROTO
#		    uci_set lxc.$CT_NR.if${IF_KEY}_ipv4=$IF_IPV4

		#    if [ "$PUBLIC4_PROTO" = "static" ] ; then
		#	uci_set lxc.$CT_NR.if${IF_KEY}_ipv4=$IF_IPV4
		#    fi


		elif [ "$IF_TYPE" = "management" ]; then
		
		    uci_set lxc.$CT_NR.if${IF_KEY}_type=veth
		    uci_set lxc.$CT_NR.if${IF_KEY}_pair=$IF_PAIR
		    uci_set lxc.$CT_NR.if${IF_KEY}_name=$IF_NAME
		    uci_set lxc.$CT_NR.if${IF_KEY}_netconf=local
		    uci_set lxc.$CT_NR.if${IF_KEY}_mac=$IF_MAC
#		    uci_set lxc.$CT_NR.if${IF_KEY}_ipv6_proto=static
#		    uci_set lxc.$CT_NR.if${IF_KEY}_ipv6=$IF_IPV6


		elif [ "$IF_TYPE" = "isolated" ] && [ "$IF_VLANTAG" ]; then

		    uci_set lxc.$CT_NR.if${IF_KEY}_type=vlan
		    uci_set lxc.$CT_NR.if${IF_KEY}_name=$IF_NAME
		    uci_set lxc.$CT_NR.if${IF_KEY}_vlanphy=$IF_PARENT
		    uci_set lxc.$CT_NR.if${IF_KEY}_vlantag=$IF_VLANTAG

		else
		    err $FUNCNAME "Failed allocating sliver_id=$SL_ID if_type=$IF_TYPE" soft
		    continue
		fi

	    fi
	done


	uci_set $SLV_CFG.$SL_ID.state=allocated path=$OUT_DIR

	uci_show $SLV_CFG.$SL_ID path=$OUT_DIR | sed s/$SLV_CFG/confine-slivers/ | uci_merge confine-slivers

	uci_show confine-slivers.$SL_ID | uci_dot_to_file confine-slivers
    fi

}


confine_sliver_undeploy() {

    # echo "$FUNCNAME $# $@" >&2
    
    local LXC_IMAGES_PATH=$( uci_get lxc.general.lxc_images_path )

    local SL_ID=
    for SL_ID in $( [ "$1" = "all" ] && \
	( uci_get_sections confine-slivers sliver soft,quiet || true ) || \
	check_slice_id $1 ); do
	
	confine_sliver_stop $SL_ID > /dev/null
	
	local LXC_IMAGES_PATH=$( uci_get lxc.general.lxc_images_path )
	local SL_STATE=$( uci_get confine-slivers.$SL_ID.state soft )
	local CT_NR=$( uci_get confine-slivers.$SL_ID.sliver_nr soft )

	if ! [ "$CT_NR" ]; then
		CT_NR=$( uci_get_section_by_option "lxc" "container" "tag" "confine-sliver-$SL_ID" "quiet,soft")
	fi

	if [ "$CT_NR" ]; then
	    umount -f $LXC_IMAGES_PATH/$CT_NR/rootfs || true
	    umount -f $LXC_IMAGES_PATH/$CT_NR/overlay.mount || true
	    rm -rf $LXC_IMAGES_PATH/$CT_NR/
	fi
	
	if [ "$CT_NR" ] && ( [ "$SL_STATE" = "deployed" ] || [ "$SL_STATE" = "deploying" ] ); then
		
	    uci_set confine-slivers.$SL_ID.state=allocated
	    
	elif ! [ "$CT_NR" ] || [ "$( uci_get confine-slivers.$SL_ID.state soft )" != "allocated" ]; then
	    err $FUNCNAME "Failed retrieving sliver_nr for slice_id=$SL_ID or NOT in deployed state" soft
	fi
    done
}


confine_sliver_deploy() {

    # echo "$FUNCNAME $# $@" >&2
CONFINE_SLIVER_DISK_MB=150

    local SL_ID=$( check_slice_id $1 )
#   local SRC="${2:--}"
    local SRC_CFG=$( date +%s )-$BASHPID-deploy
    local SRC_DIR=$CONFINE_RPC_DIR
    
    local LXC_IMAGES_PATH=$( uci_get lxc.general.lxc_images_path )
    local LXC_TEMPLATES_PATH=$( uci_get lxc.general.lxc_templates_path )
    local LXC_SCRIPTS_PATH=$( uci_get lxc.general.lxc_scripts_path )
    
#    cat $SRC > $SRC_DIR/$SRC_CFG
#    cat $SRC_DIR/$SRC_CFG >&2

    local NODE_ID=$( uci_get confine.node.id )
    local CT_NR=$( uci_get confine-slivers.$SL_ID.sliver_nr soft )
    
#   if  [ "$( uci_get $SRC_CFG.${SL_ID}_${NODE_ID} soft,path=$SRC_DIR )" = "sliver" ] && \

    if  [ "$( uci_get confine-slivers.$SL_ID soft )" = "sliver" ] && \
	[ "$( uci_get confine-slivers.$SL_ID.state soft )" = "allocated" ] && \
	[ "$CT_NR" ]; then

	uci_set confine-slivers.$SL_ID.state=deploying

	mkdir -p $LXC_IMAGES_PATH/$CT_NR

	# Install sliver template:
	local FS_URL=$( uci_get confine-slivers.$SL_ID.fs_template_url soft,quiet )
	local FS_TPYE=$( uci_get confine-slivers.$SL_ID.fs_template_type soft,quiet )

	if [ $FS_URL ]; then
	
	    local FS_COMP=$( ( echo $FS_URL | grep -e "\.tgz$" >/dev/null && echo "tgz" ) ||\
                         ( echo $FS_URL | grep -e "\.tar\.gz$" >/dev/null && echo "tar.gz" ) ||\
                         ( echo $FS_URL | grep -e "\.gz$" >/dev/null && echo "gz" ) )
	    
	    local FS_NAME=$(echo $FS_URL | awk -F'/' '{print $(NF)}' | awk -F".${FS_COMP}" '{print $1}')
	    local FS_SITE=$(echo $FS_URL | awk -F"${FS_NAME}.${FS_COMP}" '{print $1}')
	    
	    [ "$FS_URL" = "${FS_SITE}${FS_NAME}.${FS_COMP}" ] ||\
                   err $FUNCNAME "Invalid $FS_URL != ${FS_SITE}${FS_NAME}.${FS_COMP}"
	    
	    if ! [ -d $LXC_TEMPLATES_PATH/$FS_NAME.dir ]; then
		    mkdir -p $LXC_TEMPLATES_PATH/$FS_NAME.dir && \
		    tar --absolute-names --no-overwrite-dir -xzf $LXC_TEMPLATES_PATH/$FS_NAME.$FS_COMP  -C "$LXC_TEMPLATES_PATH/$FS_NAME.dir/" || {
#		    install_url $FS_URL $FS_SITE $FS_NAME $FS_COMP $LXC_TEMPLATES_PATH $LXC_TEMPLATES_PATH/$FS_NAME.dir install,soft || {
			rm -rf $LXC_TEMPLATES_PATH/$FS_NAME.dir
			rm -f $LXC_TEMPLATES_PATH/$FS_NAME
			err $FUNCNAME "installing sliver=$SL_ID template to $LXC_TEMPLATES_PATH/$FS_NAME.dir failed!"
		    }
	    fi
	fi
	
	
	# Install empty sliver overlay:
	local FS_SIZE_MB=$( uci_get confine-slivers.$SL_ID.disk_mb soft,quiet || echo $CONFINE_SLIVER_DISK_MB )
	
	[ "$(df -P $LXC_IMAGES_PATH/$CT_NR/ | tail -1 | awk '{print $4}')" -gt "$(( ( $FS_SIZE_MB ) / 1024 ))" ] &&\
		dd if=/dev/zero of=$LXC_IMAGES_PATH/$CT_NR/overlay.ext4 bs=1M count=$FS_SIZE_MB &&\
		mkdir -p $LXC_IMAGES_PATH/$CT_NR/overlay.mount/ &&\
		mkfs.ext4 -F $LXC_IMAGES_PATH/$CT_NR/overlay.ext4 \
		&&\
		mount -w -o loop,noatime,nodiratime,norelatime $LXC_IMAGES_PATH/$CT_NR/overlay.ext4 $LXC_IMAGES_PATH/$CT_NR/overlay.mount || {
			confine_sliver_undeploy $SL_ID
			err $FUNCNAME "installing sliver=$SL_ID overlay failed!"
		}


	# Install sliver sliver overlay data:
	local OVERLAY_URL=$( uci_get confine-slivers.$SL_ID.overlay_url soft,quiet )
	
	if [ -d $LXC_IMAGES_PATH/$CT_NR/overlay.mount ] && [ $OVERLAY_URL ]; then

	    local OVERLAY_COMP=$( ( echo $OVERLAY_URL | grep -e "\.tgz$" >/dev/null && echo "tgz" ) ||\
                         ( echo $OVERLAY_URL | grep -e "\.tar\.gz$" >/dev/null && echo "tar.gz" ) ||\
                         ( echo $OVERLAY_URL | grep -e "\.gz$" >/dev/null && echo "gz" ) )
	    
	    local OVERLAY_NAME=$(echo $OVERLAY_URL | awk -F'/' '{print $(NF)}' | awk -F".${OVERLAY_COMP}" '{print $1}')
	    local OVERLAY_SITE=$(echo $OVERLAY_URL | awk -F"${OVERLAY_NAME}.${OVERLAY_COMP}" '{print $1}')
	    
	    [ "$OVERLAY_URL" = "${OVERLAY_SITE}${OVERLAY_NAME}.${OVERLAY_COMP}" ] ||\
                   err $FUNCNAME "Invalid $OVERLAY_URL != ${OVERLAY_SITE}${OVERLAY_NAME}.${OVERLAY_COMP}"
	    
	    install_url $OVERLAY_URL $OVERLAY_SITE $OVERLAY_NAME $OVERLAY_COMP $LXC_TEMPLATES_PATH $LXC_IMAGES_PATH/$CT_NR/overlay.mount install,soft &&\
    	    echo "installed overlay data $OVERLAY_URL to $LXC_IMAGES_PATH/$CT_NR/overlay.mount" || {
		confine_sliver_undeploy $SL_ID
		err $FUNCNAME "installing sliver=$SL_ID overlay data failed!"
	    }
	    
	else
		echo "NO overlay data available"
	fi


	# Install sliver rootfs:
	[ -d $LXC_TEMPLATES_PATH/$FS_NAME.dir ] && [ -d $LXC_IMAGES_PATH/$CT_NR/overlay.mount ] &&\
		mkdir -p $LXC_IMAGES_PATH/$CT_NR/rootfs/ &&\
		echo "installed sliver rootfs" &&\
		mount -t overlayfs -o lowerdir=$LXC_TEMPLATES_PATH/$FS_NAME.dir,upperdir=$LXC_IMAGES_PATH/$CT_NR/overlay.mount confine-sliver-$SL_ID $LXC_IMAGES_PATH/$CT_NR/rootfs/ || {
			confine_sliver_undeploy $SL_ID
			err $FUNCNAME "installing sliver=$SL_ID rootfs failed!"
		}


	# Install sliver exp_data:
	local EXP_URL=$( uci_get confine-slivers.$SL_ID.exp_data_url soft,quiet )
	
	if [ -d $LXC_IMAGES_PATH/$CT_NR/rootfs ] && [ $EXP_URL ]; then

	    local EXP_COMP=$( ( echo $EXP_URL | grep -e "\.tgz$" >/dev/null && echo "tgz" ) ||\
                         ( echo $EXP_URL | grep -e "\.tar\.gz$" >/dev/null && echo "tar.gz" ) ||\
                         ( echo $EXP_URL | grep -e "\.gz$" >/dev/null && echo "gz" ) )
	    
	    local EXP_NAME=$(echo $EXP_URL | awk -F'/' '{print $(NF)}' | awk -F".${EXP_COMP}" '{print $1}')
	    local EXP_SITE=$(echo $EXP_URL | awk -F"${EXP_NAME}.${EXP_COMP}" '{print $1}')
	    
	    [ "$EXP_URL" = "${EXP_SITE}${EXP_NAME}.${EXP_COMP}" ] ||\
                   err $FUNCNAME "Invalid $EXP_URL != ${EXP_SITE}${EXP_NAME}.${EXP_COMP}"
	    	    
	    install_url $EXP_URL $EXP_SITE $EXP_NAME $EXP_COMP $LXC_TEMPLATES_PATH $LXC_IMAGES_PATH/$CT_NR/rootfs install,soft &&\
	    echo "installed sliver exp_data" || {
		confine_sliver_undeploy $SL_ID
		err $FUNCNAME "installing sliver=$SL_ID exp_data failed!"
	    }
	fi


	# Install ro sliver confine data:
	if [ -d $LXC_IMAGES_PATH/$CT_NR/rootfs ]; then
		mkdir -p $LXC_IMAGES_PATH/$CT_NR/confine
		echo $(( 16#${SL_ID} )) > $LXC_IMAGES_PATH/$CT_NR/confine/slice-id
		echo $(( 16#${NODE_ID} )) > $LXC_IMAGES_PATH/$CT_NR/confine/node-id
		[ -x $LXC_TEMPLATES_PATH/busybox-static ] || cp /bin/busybox-static $LXC_TEMPLATES_PATH/busybox-static || true
		[ -x $LXC_TEMPLATES_PATH/busybox-static ] && ln $LXC_TEMPLATES_PATH/busybox-static $LXC_IMAGES_PATH/$CT_NR/confine/busybox-static || true
		echo "installed sliver confine data"
	fi	
	
	# Finish sliver deployment:
	lxc.lib lxc_create $CT_NR lxc.$CT_NR # customization occurs here
	uci_set confine-slivers.$SL_ID.state=deployed
	uci_show confine-slivers.$SL_ID | uci_dot_to_file confine-slivers
	echo "$FUNCNAME $SL_ID done"

    else
	err $FUNCNAME "slice_id=$SL_ID not properly allocated"
    fi
}





confine_sliver_firewall_stop() {

#    local SL_ID=$( check_slice_id $1 )
#    local CT_NR=$( uci_get confine-slivers.$SL_ID.sliver_nr )
    local CT_NR=$1

    local IF_KEYS="$( uci_get lxc.general.lxc_if_keys )"

    local IF_KEY=

    for IF_KEY in $IF_KEYS; do

	local IF_PAIR=$(    uci_get lxc.$CT_NR.if${IF_KEY}_pair     soft,quiet )

	if [ "$IF_PAIR" ]; then

	    local EBARGS=

	    ebtables -L FORWARD | grep $IF_PAIR | while read EBARGS; do ebtables -D FORWARD $EBARGS ; done
	fi
    done
}

confine_sliver_firewall_restart() {

    local SL_ID=$( check_slice_id $1 )
    local CT_NR=$( uci_get confine-slivers.$SL_ID.sliver_nr )

    confine_sliver_firewall_stop $CT_NR

    local IF_KEYS="$( uci_get lxc.general.lxc_if_keys )"

    local IF_KEY=

    for IF_KEY in $IF_KEYS; do

	local IF_TYPE="$(    uci_get lxc.$CT_NR.if${IF_KEY}_type     soft,quiet )"
	local IF_NETCONF="$( uci_get lxc.$CT_NR.if${IF_KEY}_netconf  soft,quiet )"

	if [ "$IF_TYPE" == "veth" ] || [ "$IF_NETCONF" ]; then
	    echo
	    local IF_PAIR="$(     uci_get lxc.$CT_NR.if${IF_KEY}_pair )"

	    local IF_MAC="$(      uci_get lxc.$CT_NR.if${IF_KEY}_mac )"
	    
	    local IF_IPV4="$(     uci_get confine-slivers.$SL_ID.if${IF_KEY}_ipv4 soft,quiet | cut -d '/' -f 1 )"
	    local IF_PROT4="$(    uci_get confine-slivers.$SL_ID.if${IF_KEY}_ipv4_proto soft,quiet )"
	    local IF_IPV6="$(     uci_get confine-slivers.$SL_ID.if${IF_KEY}_ipv6 soft,quiet | cut -d '/' -f 1 )"

	    # set default policy ...
	    # however, due to a supposed ebtables bug causing IPv4/UDP fragmentation on ACCEPTED UPD ports to fail
	    # the follosing line is sommented in favor of what follows afterwards:
	    # ebtables -I FORWARD -i $IF_PAIR -j DROP
	    ebtables -I FORWARD -i $IF_PAIR -p ! IPv4 -j DROP
	    ebtables -I FORWARD -i $IF_PAIR -p IPv4 --ip-proto ! UDP -j DROP

	    # enable white list ...
	    local EBTARG=
	    local EBTCMD=
	    cat /etc/confine-ebtables.lst | awk -F'#' '{print $1}' | grep -e "^ *-p" | while read EBTARG; do
		EBTCMD="ebtables -I FORWARD -i $IF_PAIR $EBTARG"
		echo "$EBTCMD" >&2
		$EBTCMD
	    done

	    ebtables -I FORWARD -i $IF_PAIR -p IPv4 --ip-proto UDP --ip-sport 0:1023  -j DROP

	    # set general rules ...
	    ebtables -I FORWARD -i $IF_PAIR -p IPv4 $( [ "$IF_IPV4" ] && echo "--ip-src ! $IF_IPV4" || echo "--ip-src 0.0.0.0/0" ) -j DROP
	    ebtables -I FORWARD -i $IF_PAIR -p IPv6 $( [ "$IF_IPV6" ] && echo "--ip6-src ! $IF_IPV6" || echo "--ip6-src ::/0" ) -j DROP
	    
	    if [ "$IF_PROT4" ] && [ "$IF_PROT4" = "dhcp" ]; then
		    ebtables -I FORWARD -i $IF_PAIR -p IPv4 --ip-src 0.0.0.0 --ip-proto udp --ip-sport 68 --ip-dport 67 -j ACCEPT
	    fi
	    
	    ebtables -I FORWARD -i $IF_PAIR -s ! $IF_MAC -j DROP 
	fi

    done
}

confine_sliver_start() {

    # echo "$FUNCNAME $# $@" >&2

    local SL_ID=$( check_slice_id $1 )
    local CT_NR=$( uci_get confine-slivers.$SL_ID.sliver_nr soft )
    local LXC_IMAGES_PATH=$( uci_get lxc.general.lxc_images_path )

    if 	[ "$( uci_get confine-slivers.$SL_ID soft )" = "sliver" ] && \
	[ "$( uci_get confine-slivers.$SL_ID.state soft )" = "deployed" ] && \
	[ "$CT_NR" ] && \
	[ -d $LXC_IMAGES_PATH/$CT_NR/rootfs ] && \
	[ -f $LXC_IMAGES_PATH/$CT_NR/config ] ; then

	uci_set confine-slivers.$SL_ID.state=starting

	confine_sliver_firewall_restart $SL_ID

	lxc.lib lxc_start $CT_NR

	if lxc-info -n $CT_NR 2>/dev/null | grep -e "^state:" | grep -e "RUNNING" >/dev/null ; then
	    uci_set confine-slivers.$SL_ID.state=started
	else
	    lxc.lib lxc_stop $CT_NR
	    uci_set confine-slivers.$SL_ID.state=error
	    err $FUNCNAME "Failed starting slice_id=$SL_ID" soft
	fi

    else
	err $FUNCNAME "slice_id=$SL_ID not properly deployed"
    fi

}


confine_sliver_stop() {

    # echo "$FUNCNAME $# $@" >&2

    local SL_ID=
    for SL_ID in $( [ "$1" = "all" ] && \
	( uci_get_sections confine-slivers sliver soft,quiet || true ) || \
	check_slice_id $1 ); do

	local CT_NR=$( uci_get confine-slivers.$SL_ID.sliver_nr soft )
	if ! [ "$CT_NR" ]; then
		CT_NR=$( uci_get_section_by_option "lxc" "container" "tag" "confine-sliver-$SL_ID" "quiet,soft")
	fi
	

	if  [ "$CT_NR" ] ; then
	    
	    if lxc-info -n $CT_NR 2>/dev/null | grep -e "^state:" | grep -e "RUNNING" >/dev/null ; then
		lxc.lib lxc_stop $CT_NR
	    fi

	    confine_sliver_firewall_stop $CT_NR
	    
	    if [ "$( uci_get confine-slivers.$SL_ID.state soft )" = "started" ] ; then
		uci_set confine-slivers.$SL_ID.state=deployed
	    fi
	    
	else
	    err $FUNCNAME "Failed retrieving sliver_nr for slice_id=$SL_ID " soft
	fi
    done
}



confine_sliver_remove() {

    local SLIVER_ARG=$1
    local OPT_CMD=${2:-}
    local CMD_QUIET=$( echo "$OPT_CMD" | grep -e "quiet" > /dev/null && echo "quiet," )

    echo "$FUNCNAME $# $@" >&2

    local SLICE_ID=
    for SLICE_ID in $( [ "$SLIVER_ARG" = "all" ] && \
	( uci_get_sections confine-slivers sliver soft,quiet || true ) || \
	check_slice_id $SLIVER_ARG ); do

	local CT_NR=$( uci_get confine-slivers.$SLICE_ID.sliver_nr soft,$CMD_QUIET )
	if ! [ "$CT_NR" ]; then
		CT_NR=$( uci_get_section_by_option "lxc" "container" "tag" "confine-sliver-$SLICE_ID" "quiet,soft")
		err $FUNCNAME "retried container_nr=$CT_NR for slice_id=$SLICE_ID" soft
	fi
	
	if [ "$CT_NR" ] ; then
		confine_sliver_stop $SLICE_ID
		confine_sliver_undeploy $SLICE_ID
		lxc.lib lxc_purge $CT_NR
	fi
	
	local SLIVER_ID=
	local SLIVERS="$( for SLIVER_ID in $( uci_get_sections confine-slice-attributes sliver ); \
	    do echo $SLIVER_ID | grep -e "${SLICE_ID}_"; done )"

	for SLIVER_ID in $SLIVERS ; do
	    uci_del confine-slice-attributes.$SLIVER_ID
	done

	uci_del confine-slivers.$SLICE_ID soft,$CMD_QUIET

    done
}

confine_sliver_dump_overlay() {

	local SL_ID=$( check_slice_id $1 )
	local CT_NR=$( uci_get confine-slivers.$SL_ID.sliver_nr soft )
	local LXC_IMAGES_PATH=$( uci_get lxc.general.lxc_images_path )
	local DUMP_PATH=/root/overlay-dump.tgz
	local NODE_ID=$( uci_get confine.node.id )

	if [ "$( uci_get confine-slivers.$SL_ID soft )" = "sliver" ] && \
	   [ "$( uci_get confine-slivers.$SL_ID.state soft )" = "deployed" ] && \
	   [ "$CT_NR" ] && \
	   [ -d $LXC_IMAGES_PATH/$CT_NR/overlay.mount ] ; then
		tar -czvf $DUMP_PATH -C $LXC_IMAGES_PATH/$CT_NR/overlay.mount/ .
		echo "overlay of sliver=$SL_ID dumped to $DUMP_PATH"
		echo "overlay can be downloaded with: vct_node_scp $NODE_ID remote:/$DUMP_PATH /var/lib/vct/downloads/"
	else
		echo "sliver=$SL_ID NOT in deployed state"
	fi
}

confine_info() {

    local SLIVER_ARG=${1:-all}
    local OPT_CMD=${2:-}
    local CMD_QUIET=$( echo "$OPT_CMD" | grep -e "quiet" > /dev/null && echo "quiet," )

    printf "CONFINE node-id=0x%s node-state=%s daemon-pid=%s\n" \
	$( uci_get confine.node.id soft,quiet ) \
	$( uci_get confine.node.state soft,quiet ) \
	$( [ -f /var/run/confine/pid ] && [ -d /proc/$(cat /var/run/confine/pid) ] && cat /var/run/confine/pid || echo "stopped" )
    printf "%-16s %-3s %-5s %-10s %-30s \n" slice-id lxc pid state name
    echo   "----------------------------------------------------------"

    local SLICE_ID=
    for SLICE_ID in $( [ "$SLIVER_ARG" = "all" ] && \
	( uci_get_sections confine-slivers sliver soft,quiet || true ) || \
	check_slice_id $SLIVER_ARG ); do

	local SLIVER_NR="$( uci_get confine-slivers.$SLICE_ID.sliver_nr soft,quiet )"
	local SLIVER_STATE="$( uci_get confine-slivers.$SLICE_ID.state soft,quiet )"
	local LXC_PID="$( lxc-info -n $SLIVER_NR 2>/dev/null | grep pid: | awk '{print $2}' )"
	local SLIVER_EXP_NAME="$( uci_get confine-slivers.$SLICE_ID.exp_name soft,quiet )"


	printf "0x%-14s %-3s %-5s %-10s %-30s \n" \
	    $SLICE_ID $SLIVER_NR $LXC_PID $SLIVER_STATE "'$SLIVER_EXP_NAME'"

    done
}


confine_daemon_stop() {

	echo
	echo "stopping confine daemon..."

	local CPID=$( [ -f /var/run/confine/pid ] && cat /var/run/confine/pid )

	while [ "$CPID" ] && [ -d /proc/$CPID ] ;do
		kill -15 $CPID
		sleep 1
		[ -d /proc/$CPID ] && echo "confine-daemon-pid=$CPID still running. This may take a while..."
		CPID=$( [ -f /var/run/confine/pid ] && cat /var/run/confine/pid )
	done
	confine_info
}


confine_daemon_continue() {
	local interactive=${1:-no}

	echo
	echo "restarting confine daemon..."

	if ! [ "$( uci -q get confine.node.start_daemon )" = "0" ] ; then
		if echo $interactive | grep "^-i" > /dev/null; then
			/usr/lib/lua/confine/confine.lua --interactive
		else
			/usr/lib/lua/confine/confine.lua >/dev/null 2>&1 &
		fi
	fi


	confine_info
}

confine_daemon_update() {
	local URLS="$1"

	confine_daemon_stop

	echo
	echo "going to opkg --force-depends install $URLS"
	opkg --force-depends install $URLS

	confine_daemon_continue
}

help() {
       cat <<EOF
confine_info
confine_node_enable                             # enable confine system
confine_node_disable                            # disable confine system
confine_daemon_stop                             # temporary stop confine daemon, (slivers persist)
confine_daemon_continue                         # continue confine daemon
confine_daemon_update   <URL>                   # update (stop,update,continue) confine daemon with opkg of given URL
confine_sliver_allocate <SLICE_ID> [BATCH_FILE]
confine_sliver_deploy   <SLICE_ID> [BATCH_FILE]
confine_sliver_start    <SLICE_ID|all>
confine_sliver_stop     <SLICE_ID|all>
confine_sliver_undeploy <SLICE_ID|all>
confine_sliver_remove   <SLICE_ID|all>
confine_sliver_dump_overlay <SLICE_ID>
EOF
}


CMD=$( echo $0 | awk -F'/' '{print $(NF)}' )

if [ "$CMD" = "confine.lib" ]; then

    if [ "${1:-}" ]; then
	"$@"
    else
	echo "hmmm args: $@"
	help
    fi

else

    case "$CMD" in
	confine_node_enable|confine_node_disable|confine_daemon_stop|confine_daemon_continue|confine_daemon_update) $CMD "${1:-}";;
	confine_sliver_allocate|confine_sliver_deploy) $CMD $1 ${2:-};;
	confine_sliver_start|confine_sliver_stop|confine_sliver_undeploy|confine_sliver_remove|confine_sliver_dump_overlay) $CMD $1 ${2:-};;
	confine_info) $CMD ${1:-} ${2:-};;
	*) help;;
    esac

fi
